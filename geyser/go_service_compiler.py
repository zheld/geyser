#!/usr/bin/env python
# coding=utf-8
import os

from geyser.resources_sql.converter import *
from geyser.manifest_creater import ManifestFile
from geyser.generator.FSItem.directory import Directory
from geyser.resources_go.copy_core import CopyCoreHere

methods = {"int64": "ToInt64",
           "string": "ToString",
           "int": "ToInt",
           "bool": "ToBool",
           "time.Time": "ToTime",
           "[]string": "ToStringArray",
           "float32": "ToFloat32",
           "float64": "ToFloat64",
           "[]float64": "ToFloat64Array",
           "[][]float64": "ToArrayFloat64Array",
           }


class GoServiceCompiler:
    def __init__(self, service, dir):
        self.servdir = dir
        self.service = service
        self.apimap = ["echo"]
        self.async_apimap = []

        # directory of the created service
        '''
        /go_<service_name>
            struct_db.json
            /dev_<service_name>
                /<service_name>
                    manifest.json
                /pkg
                /src
                    /<table_name>
                        <table_name>.data.go
                        <table_name>.bl.go
                    /core
                    /manager
                        manager.data.go
                        manager.bl.go
                    ...
                procedures.sql
                main.go
                <service_name>_db.sql
        '''

        # creation of the service development directory and necessary environment files
        self.service_dir = Directory(None)
        if self.service_dir:
            self.service_dir.setPath(self.servdir)

            # create file of serialization of the current database
            self.structure_db_json = self.service_dir.addJsonFile('struct_db')

            # deployment directory and service builds
            self.service_build_dir = self.service_dir.addDirectory(self.service.Name())
            # if self.service_build_dir:

            # manifest file
            self.manifest_json = ManifestFile(self.service, self.service_build_dir)
            self.service_build_dir.addItem(self.manifest_json)

            # directory "package"
            self.pkg_dir = self.service_dir.addDirectory('pkg')

            # directory of the main service code and libraries
            self.src_dir = self.service_dir.addGoPackage('src')
            if self.src_dir:

                # service manager package
                self.manager = self.src_dir.addGoPackage("manager")
                if self.manager:

                    # autogenerated manager file
                    self.manager_data_go = self.manager.addGoFile("manager.data")

                    # start inbound event handlers
                    self.manager_data_run_event_handlers = self.manager_data_go.addFunction("RunEventHandlers")

                    # custom file manager
                    self.manager_bl_go = self.manager.addGoFile("manager.bl", only_create = True)

                    # api сервиса
                    self.service_api_go = self.manager.addGoFile("api", only_create = True)

            # custom sql procedure file
            self.sql_procedure = self.service_dir.addSQLFile("procedures", only_create = True)

            # main file
            self.main_go = self.service_dir.addGoFile("main", package_name = "main")

            # database converter file
            self.db_sql = self.service_dir.addSQLFile("database".format(self.service.Name()))

    def buidMain(self):
        self.main_go.addImport("core")

        # main function
        foo_main = self.main_go.addFunction("main")

        # check custom code for api methods
        self.ParseUserCode(self.src_dir.getPath())
        map_list = "\n".join('        "{funame}": {funame},'.format(funame = funame) for funame in self.apimap)
        # async_map_list = "\n".join( '        "{funame}": {funame}_async,'.format( funame = funame ) for funame in self.async_apimap )

        body = '''    api := map[string]core.HandlerFoo<@
{map_list}
    @>
    core.ServiceStart(api)'''.format(map_list = map_list)
        foo_main.addBody(body)

        # echo function
        foo_echo = self.main_go.addFunction("echo")
        foo_echo.addArgs("args []interface{}")
        foo_echo.addResults("interface{}")
        foo_echo.addBody('''    return []interface<@@><@200, args[0]@>''')

    def Build(self, conf):
        print('Database conversion...')
        body = ['-- TABLE CONVERTER  {spl}'.format(spl = '-' * 110)]
        self.db_sql.Write(body)

        converter = DataBaseConverter(self.service, self.structure_db_json, conf)
        body = converter.GetTableCode()
        self.db_sql.Write(body)

        # copying custom stored procedures
        body = ['-- CUSTOM functions {spl}'.format(spl = '-' * 110)]
        self.db_sql.Write(body)
        read_sql = self.sql_procedure.Read()
        self.db_sql.Write(read_sql)

        body = ['-- DATAS functions {spl}'.format(spl = '-' * 110)]
        self.db_sql.Write(body)
        for data in self.service.getDataList():
            data.Build(self.src_dir, self.db_sql, self)

        # write changes into db
        sql = self.db_sql.Text()
        converter.Convert(sql)

        # main.go
        self.buidMain()

        # build the main directory of service
        self.service_dir.Build()

        # copy core if not exist
        CopyCoreHere(self.src_dir.getPath())

    def ParseUserCode(self, dir_path, package=""):
        try:
            for item in os.listdir(dir_path):
                item_path = "{}/{}".format(dir_path, item)
                if os.path.isdir(item_path) and item not in ["core", "github.com"]:
                    path = package + "/" + item if package else item
                    self.ParseUserCode(item_path, path)
                    continue
                file = item
                if '.go' in file:
                    with open(item_path) as gofile:
                        lines = gofile.read().splitlines()
                        for number, row in enumerate(lines):
                            if '//!api' in row:
                                row_splitted = row.split(" ")
                                custom_funcname = row_splitted[1].strip()
                                funcname = ""
                                try:
                                    funcname = self.CreateApiWrapper(lines[number + 1], custom_funcname, package)
                                except Exception as e:
                                    print("error in parse user code: " + str(e))
                                    raise e

                                self.apimap.append(funcname)
                                self.async_apimap.append(funcname)
                            if "//!event" in row:
                                split_macros = row.split(" ")
                                event_info = split_macros[0].strip().split(".")
                                server_name = event_info[1]

                                listen_mode = "perm"
                                if len(event_info) > 2:
                                    listen_mode = event_info[2]

                                event_name = split_macros[1].strip()
                                print("event_name: " + event_name)
                                self.CreateBindToEvents(lines[number + 1], package, server_name, event_name, listen_mode)

        except:
            pass

    def CreateBindToEvents(self, func_row, package_path, server_name, event_name, listen_mode):
        # package name
        package = package_path.split("/")[-1]
        self.manager_data_go.addImport(package_path)

        # function name
        start_name = func_row.find(" ") + 1
        first_sk = func_row.find("(")
        func_name = func_row[start_name:first_sk]
        full_func_name = "{package}.{func}".format(package = package,
                                                   func = func_name)

        # function args
        second_sk = func_row.find(")", first_sk)
        args = func_row[first_sk + 1:second_sk].strip()
        # print("args: " + args)
        var_list = args.split(",")

        api_args_list = []
        for var in var_list:
            if var:
                name, _type = var.strip().split(" ")
                api_args_list.append([name.strip(), _type.strip()])

        funcname = "{package}_{func_name}".format(package = package, func_name = func_name.lower())

        self.manager_data_go.addImport("core")
        if listen_mode == "perm":
            body = '    core.CreateHandleEvent("{server_name}", "{event}", {foo_name})'.format(server_name = server_name,
                                                                                               event = event_name,
                                                                                               foo_name = funcname)
        elif listen_mode == "temp":
            body = '    core.CreateTemporaryListener("{server_name}", "{event}", {foo_name})'.format(server_name = server_name,
                                                                                                     event = event_name,
                                                                                                     foo_name = funcname)

        self.manager_data_run_event_handlers.addBody(body)

        callback = self.manager_data_go.addFunction(funcname)
        callback.addArgs("args []interface{}")

        out_args_list = []
        args_list = []
        for number, args_object in enumerate(api_args_list):
            if "interface" in args_object[1]:
                out_args_list.append("    {name} := args[{number}]".format(name = args_object[0],
                                                                           number = number))
            else:
                out_args_list.append("    {name} := core.{method}(args[{number}])".format(name = args_object[0],
                                                                                          method = methods[args_object[1]],
                                                                                          number = number))
            args_list.append(args_object[0])

        body = '''{out_args}
    {full_func_name}({args})'''.format(out_args = "\n".join(out_args_list),
                                       full_func_name = full_func_name,
                                       args = ", ".join(args_list)
                                       )

        callback.addBody(body)

    def CreateApiWrapper(self, func_row, custom_funcname, package_path):
        # package name
        package = package_path.split("/")[-1]
        # print("package: " + package)
        self.main_go.addImport(package_path)

        # function name
        start_name = func_row.find(" ") + 1
        first_sk = func_row.find("(")
        func_name = func_row[start_name:first_sk]
        full_func_name = "{package}.{func}".format(package = package,
                                                   func = func_name)
        # print("func: " + full_func_name)

        # function args
        second_sk = func_row.find(")", first_sk)
        args = func_row[first_sk + 1:second_sk].strip()
        # print("args: " + args)
        var_list = args.split(",")

        api_args_list = []
        for var in var_list:
            if var:
                name, _type = var.strip().split(" ")
                api_args_list.append([name.strip(), _type.strip()])
        # print("api args: " + str( api_args_list ))

        # function result
        tmp = func_row[second_sk + 1: func_row.find("\n")]
        result = tmp.replace("(", "")
        result = result.replace(")", "").strip()
        # print("results: " + result)

        var_list = result.split(",")
        first_res = var_list[0].strip()

        if not custom_funcname:
            funcname = "{package}_{func_name}".format(package = package, func_name = func_name.lower())
        else:
            funcname = custom_funcname

        wrapper = self.main_go.addFunction(funcname)
        wrapper.addArgs("args []interface{}")
        wrapper.addResults("interface{}")

        out_args_list = []
        args_list = []
        args_count = 0
        for number, args_object in enumerate(api_args_list):
            out_args_list.append("    {name} := core.{method}(args[{number}])".format(name = args_object[0],
                                                                                      method = methods[args_object[1]],
                                                                                      number = number))
            args_list.append(args_object[0])
            args_count += 1

        body = '''    if len(args) != {args_count} <@
        return []interface<@@><@500, "no match count params"@>
    @>
{out_args}    res, err := {full_func_name}({args})
    if err != nil <@
        return []interface<@@><@500, err.Error()@>
    @> else <@
        return []interface<@@><@200, res@>
    @>'''.format(out_args = ("\n".join(out_args_list) + "\n") if args_list else "",
                 full_func_name = full_func_name,
                 args = ", ".join(args_list) if args_list else "",
                 args_count = args_count
                 )
        wrapper.addBody(body)

        return funcname

    def pep_to_camel(self, pep):
        pep_list = pep.split("_")
        pep_capitalize_list = [w.title() for w in pep_list]
        return "".join(pep_capitalize_list)
